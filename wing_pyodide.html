<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>NACA Wing Generator</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    * { box-sizing: border-box; }
    body { margin: 0; font-family: system-ui, Segoe UI, Roboto, sans-serif; background: #0f1320; color: #e9eefb; }
    header { padding: 12px 16px; border-bottom: 1px solid #20263a; }
    h1 { font-size: 18px; margin: 0; }
    main { display: grid; grid-template-columns: 340px 1fr; height: calc(100vh - 58px); }
    #panel { padding: 12px; border-right: 1px solid #20263a; overflow: auto; }
    #renderer { position: relative; }
    #canvas { width: 100%; height: 100%; display: block; }
    fieldset { border: 1px solid #20263a; border-radius: 8px; padding: 12px; margin-bottom: 12px; }
    legend { padding: 0 6px; color: #9fb3ff; }
    label { display: block; font-size: 12px; margin-top: 8px; color: #b9c2e8; }
    input, select { width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #394264; background: #12172b; color: #e9eefb; }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
    button { width: 100%; padding: 10px; margin-top: 12px; border: 1px solid #394264; border-radius: 6px;
      background: #1b213a; color: #dfe7ff; cursor: pointer; }
    button:hover { background: #253057; }
    small { color: #9aa7d6; }
    .note { font-size: 12px; color: #9aa7d6; margin-top: 6px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    a { color: #9fb3ff; text-decoration: none; }
  </style>
</head>
<body>
  <header>
    <h1>NACA Wing Generator — 4-digit profiles, taper/twist/sweep/dihedral, STL export</h1>
  </header>
  <main>
    <div id="panel">
      <fieldset>
        <legend>Airfoil</legend>
        <label>NACA 4-digit code (e.g., 2412)
          <input id="naca" class="mono" type="text" value="2412" maxlength="4" />
        </label>
        <label>Points per surface (upper/lower, total ~2×)
          <input id="pts" type="number" min="50" max="800" step="10" value="200" />
        </label>
        <div class="note">Closed TE uses thickness coefficient −0.1015; coordinates are cosine-spaced.</div>
      </fieldset>

      <fieldset>
        <legend>Planform</legend>
        <div class="row">
          <div>
            <label>Span (m)
              <input id="span" type="number" min="0.05" step="0.01" value="1.0" />
            </label>
          </div>
          <div>
            <label>Span segments
              <input id="spanSegs" type="number" min="2" max="200" step="1" value="40" />
            </label>
          </div>
        </div>
        <div class="row">
          <div>
            <label>Root chord (m)
              <input id="cRoot" type="number" min="0.01" step="0.001" value="0.25" />
            </label>
          </div>
          <div>
            <label>Tip chord (m)
              <input id="cTip" type="number" min="0.01" step="0.001" value="0.10" />
            </label>
          </div>
        </div>
        <div class="row">
          <div>
            <label>Tip twist (deg, nose-down negative)
              <input id="twistTip" type="number" step="0.1" value="-3.0" />
            </label>
          </div>
          <div>
            <label>Sweep (m at tip, LE positive)
              <input id="sweep" type="number" step="0.001" value="0.10" />
            </label>
          </div>
        </div>
        <div class="row">
          <div>
            <label>Dihedral (deg)
              <input id="dihedral" type="number" step="0.1" value="5.0" />
            </label>
          </div>
          <div>
            <label>Symmetry
              <select id="sym">
                <option value="right">Right wing</option>
                <option value="left">Left wing</option>
                <option value="both" selected>Both (full span)</option>
              </select>
            </label>
          </div>
        </div>
        <div class="note">Sweep shifts the leading edge in +X; dihedral rotates around the X-axis; twist rotates around each station’s Y-axis.</div>
      </fieldset>

      <fieldset>
        <legend>Output</legend>
        <label>Surface color
          <input id="color" type="color" value="#5fa8ff" />
        </label>
        <button id="build">Build wing</button>
        <button id="export">Export STL</button>
        <div class="note">STL is exported in ASCII for readability.</div>
      </fieldset>

      <div class="note">Tip: Increase “Points per surface” and “Span segments” for smoother meshes before export.</div>
    </div>

    <div id="renderer">
      <canvas id="canvas"></canvas>
    </div>
  </main>

  <!-- Three.js modules -->
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';
    import { STLExporter } from 'https://unpkg.com/three@0.160.0/examples/jsm/exporters/STLExporter.js';

    // Scene setup
    const canvas = document.getElementById('canvas');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0f1320);
    const camera = new THREE.PerspectiveCamera(50, 1, 0.01, 200);
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    const hemi = new THREE.HemisphereLight(0xffffff, 0x334, 0.9);
    scene.add(hemi);
    const key = new THREE.DirectionalLight(0xffffff, 0.7);
    key.position.set(2, 1, 3);
    scene.add(key);

    const grid = new THREE.GridHelper(10, 40, 0x3a4a7a, 0x222a44);
    grid.rotation.x = Math.PI / 2; // XY grid
    scene.add(grid);

    const axes = new THREE.AxesHelper(0.5);
    scene.add(axes);

    // Resize
    function onResize() {
      const panelW = document.getElementById('panel').offsetWidth;
      const w = window.innerWidth - panelW;
      const h = window.innerHeight - 58;
      renderer.setSize(w, h, false);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    }
    window.addEventListener('resize', onResize);
    onResize();

    // Camera default
    camera.position.set(0.6, 0.3, 0.6);
    controls.target.set(0.2, 0.0, 0.0);

    // UI
    const ui = {
      naca: document.getElementById('naca'),
      pts: document.getElementById('pts'),
      span: document.getElementById('span'),
      spanSegs: document.getElementById('spanSegs'),
      cRoot: document.getElementById('cRoot'),
      cTip: document.getElementById('cTip'),
      twistTip: document.getElementById('twistTip'),
      sweep: document.getElementById('sweep'),
      dihedral: document.getElementById('dihedral'),
      sym: document.getElementById('sym'),
      color: document.getElementById('color'),
      build: document.getElementById('build'),
      export: document.getElementById('export'),
    };

    let wingMesh = null;

    // NACA 4-digit generator (cosine-spacing for x)
    // m = max camber, p = location of max camber, t = thickness (all as fractions of chord)
    function naca4Coordinates(code, nPointsPerSide = 200) {
      if (!/^\d{4}$/.test(code)) throw new Error('NACA code must be 4 digits, e.g., 2412.');
      const m = parseInt(code[0], 10) / 100.0;
      const p = parseInt(code[1], 10) / 10.0;
      const t = parseInt(code.slice(2), 10) / 100.0;

      // Cosine spacing (dense near LE and TE)
      const N = Math.max(50, nPointsPerSide|0);
      const x = new Array(N);
      for (let i = 0; i < N; i++) {
        const beta = Math.PI * i / (N - 1);
        x[i] = 0.5 * (1 - Math.cos(beta)); // 0..1
      }

      const yt = x.map(xi => {
        return 5 * t * (0.2969 * Math.sqrt(xi)
                      - 0.1260 * xi
                      - 0.3516 * xi * xi
                      + 0.2843 * xi * xi * xi
                      - 0.1015 * xi * xi * xi * xi);
      });

      function camber(xi) {
        if (p === 0) return { yc: 0, dy: 0 };
        if (xi < p) {
          const yc = (m / (p * p)) * (2 * p * xi - xi * xi);
          const dy = (2 * m / (p * p)) * (p - xi);
          return { yc, dy };
        } else {
          const yc = (m / ((1 - p) * (1 - p))) * ((1 - 2 * p) + 2 * p * xi - xi * xi);
          const dy = (2 * m / ((1 - p) * (1 - p))) * (p - xi);
          return { yc, dy };
        }
      }

      const upper = [];
      const lower = [];
      for (let i = 0; i < N; i++) {
        const xi = x[i];
        const { yc, dy } = camber(xi);
        const theta = Math.atan(dy);
        const xu = xi - yt[i] * Math.sin(theta);
        const yu = yc + yt[i] * Math.cos(theta);
        const xl = xi + yt[i] * Math.sin(theta);
        const yl = yc - yt[i] * Math.cos(theta);
        upper.push([xu, yu]);
        lower.push([xl, yl]);
      }

      // Build full closed loop from TE (x=1) around upper to LE (x~0) and back on lower
      const outline = [];
      // Upper surface from TE to LE
      for (let i = N - 1; i >= 0; i--) outline.push([upper[i][0], upper[i][1]]);
      // Lower surface from LE to TE
      for (let i = 0; i < N; i++) outline.push([lower[i][0], lower[i][1]]);

      return { x, upper, lower, outline }; // normalized to chord = 1
    }

    // Build spanwise stations with linear taper, twist, sweep, and dihedral
    function buildWingGeometry(params) {
      const { code, ptsPerSide, span, spanSegs, cRoot, cTip, twistTipDeg, sweep, dihedralDeg, symmetry, color } = params;
      const airfoil = naca4Coordinates(code, ptsPerSide);
      const profile = airfoil.outline; // array of [x, y] normalized

      // Choose resolution along profile
      const M = profile.length;

      // Span stations
      const S = Math.max(2, spanSegs|0);
      const halfSpan = span * (symmetry === 'both' ? 0.5 : 1.0);
      const ySign = symmetry === 'left' ? -1 : 1; // right wing positive Y

      // Prepare vertex buffer: stations × profile points
      const stations = [];
      for (let s = 0; s < S; s++) {
        const eta = s / (S - 1); // 0 root -> 1 tip
        const chord = cRoot + (cTip - cRoot) * eta;
        const twist = (twistTipDeg * Math.PI / 180) * eta;
        const dihedral = dihedralDeg * Math.PI / 180;
        const ySpan = ySign * halfSpan * eta;
        const xSweep = sweep * eta;

        // Local transform:
        // 1) Scale by chord (x along chord, z thickness up)
        // 2) Rotate by twist around local Y (span) axis
        // 3) Position: Y = span, X += sweep; rotate whole wing by dihedral around X
        const row = [];
        const cosTw = Math.cos(twist), sinTw = Math.sin(twist);
        const cosDh = Math.cos(dihedral), sinDh = Math.sin(dihedral);

        for (let i = 0; i < M; i++) {
          const xLocal = profile[i][0] * chord;
          const zLocal = profile[i][1] * chord;

          // Twist rotation about local Y: (x,z) -> (x',z')
          const xTw = xLocal * cosTw + zLocal * sinTw;
          const zTw = -xLocal * sinTw + zLocal * cosTw;

          // Position in wing coordinates before dihedral
          let X = xTw + xSweep;
          let Y = ySpan;
          let Z = zTw;

          // Dihedral rotation around X axis: (Y,Z) -> (Y',Z')
          const Yd = Y * cosDh - Z * sinDh;
          const Zd = Y * sinDh + Z * cosDh;

          row.push(new THREE.Vector3(X, Yd, Zd));
        }
        stations.push(row);
      }

      // If symmetry both, mirror to left side
      let allStations = stations;
      if (symmetry === 'both') {
        const mirror = [];
        for (let s = S - 1; s >= 0; s--) {
          const row = [];
          for (let i = 0; i < M; i++) {
            const v = stations[s][i];
            // Mirror across Y=0 plane by negating Y
            row.push(new THREE.Vector3(v.x, -v.y, v.z));
          }
          mirror.push(row);
        }
        allStations = stations.concat(mirror);
      }

      const SS = allStations.length;

      // Build faces between consecutive stations (quad -> two triangles)
      const vertices = [];
      const indices = [];

      for (let s = 0; s < SS; s++) {
        for (let i = 0; i < M; i++) {
          vertices.push(allStations[s][i].x, allStations[s][i].y, allStations[s][i].z);
        }
      }

      function vid(s, i) { return s * M + i; }

      for (let s = 0; s < SS - 1; s++) {
        for (let i = 0; i < M - 1; i++) {
          const a = vid(s, i);
          const b = vid(s + 1, i);
          const c = vid(s + 1, i + 1);
          const d = vid(s, i + 1);
          // Tri 1: a b d
          indices.push(a, b, d);
          // Tri 2: b c d
          indices.push(b, c, d);
        }
      }

      const geom = new THREE.BufferGeometry();
      geom.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
      geom.setIndex(indices);
      geom.computeVertexNormals();

      const mat = new THREE.MeshStandardMaterial({
        color: new THREE.Color(color),
        roughness: 0.6,
        metalness: 0.0,
        side: THREE.DoubleSide
      });

      const mesh = new THREE.Mesh(geom, mat);

      // Center camera on new mesh
      geom.computeBoundingSphere();
      const bs = geom.boundingSphere;
      if (bs) {
        controls.target.copy(bs.center);
        const d = bs.radius;
        camera.position.set(bs.center.x + 1.8 * d, bs.center.y + 1.0 * d, bs.center.z + 1.8 * d);
        camera.lookAt(bs.center);
      }

      return mesh;
    }

    function removeMesh() {
      if (wingMesh) {
        scene.remove(wingMesh);
        wingMesh.geometry.dispose();
        wingMesh.material.dispose();
        wingMesh = null;
      }
    }

    ui.build.addEventListener('click', () => {
      try {
        removeMesh();
        const params = {
          code: ui.naca.value.trim(),
          ptsPerSide: parseInt(ui.pts.value, 10),
          span: parseFloat(ui.span.value),
          spanSegs: parseInt(ui.spanSegs.value, 10),
          cRoot: parseFloat(ui.cRoot.value),
          cTip: parseFloat(ui.cTip.value),
          twistTipDeg: parseFloat(ui.twistTip.value),
          sweep: parseFloat(ui.sweep.value),
          dihedralDeg: parseFloat(ui.dihedral.value),
          symmetry: ui.sym.value,
          color: ui.color.value
        };
        wingMesh = buildWingGeometry(params);
        scene.add(wingMesh);
      } catch (e) {
        alert('Error: ' + e.message);
      }
    });

    ui.export.addEventListener('click', () => {
      if (!wingMesh) {
        alert('Build the wing first.');
        return;
      }
      const exporter = new STLExporter();
      const stlString = exporter.parse(wingMesh, { binary: false });
      const blob = new Blob([stlString], { type: 'text/plain' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = `wing_${ui.naca.value.trim()}_${Date.now()}.stl`;
      a.click();
      URL.revokeObjectURL(a.href);
    });

    // Animate
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>
