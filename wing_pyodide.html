<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Wing 3D (Pyodide + three.js)</title>

  <!-- Pyodide -->
  <script src="https://cdn.jsdelivr.net/pyodide/v0.28.1/full/pyodide.js"></script>

  <!-- three.js and STLExporter -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/exporters/STLExporter.js"></script>

  <style>
    body { margin: 0; font-family: Arial, sans-serif; display: flex; height: 100vh; }
    #ui { width: 320px; padding: 12px; box-sizing: border-box; background:#f5f5f5; overflow:auto; border-right:1px solid #ddd; }
    #viewport { flex: 1; display:flex; flex-direction:column; }
    #canvas-container { flex: 1; }
    label { display:block; margin-top:8px; font-size:13px; }
    input[type="text"], input[type="number"], select { width:100%; padding:6px; box-sizing:border-box; margin-top:4px; }
    button { margin-top:10px; padding:8px 10px; width:100%; }
    small { color:#666; }
  </style>
</head>
<body>
  <div id="ui">
    <h3>Wing Generator (Pyodide)</h3>

    <label>NACA 4-digit
      <input id="naca" type="text" value="2412" />
    </label>

    <label>Span (m)
      <input id="span" type="number" step="0.1" value="2.0" />
    </label>

    <label>Root chord (m)
      <input id="chord_root" type="number" step="0.01" value="0.5" />
    </label>

    <label>Tip chord (m)
      <input id="chord_tip" type="number" step="0.01" value="0.3" />
    </label>

    <label>Span stations (n_span)
      <input id="n_span" type="number" step="1" value="21" />
      <small>Reduce for faster performance</small>
    </label>

    <label>Points per surface (n_chord)
      <input id="n_chord" type="number" step="1" value="64" />
      <small>Per upper or lower surface; total chord points = n_chord*2</small>
    </label>

    <label>Root twist (deg)
      <input id="twist_root" type="number" step="0.1" value="0.0" />
    </label>

    <label>Tip twist (deg)
      <input id="twist_tip" type="number" step="0.1" value="0.0" />
    </label>

    <label>Sweep LE (deg)
      <input id="sweep" type="number" step="0.1" value="0.0" />
    </label>

    <label><input id="mirror" type="checkbox" checked /> Mirror wing (full wing)</label>

    <button id="gen">Generate wing and render</button>
    <button id="download_stl">Download STL</button>

    <hr />
    <div id="status">Loading Pyodide...</div>
  </div>

  <div id="viewport">
    <div id="canvas-container"></div>
  </div>

<script type="text/javascript">
  // three.js scene setup
  let scene, camera, renderer, controls;
  let wingMesh = null;

  function initThree() {
    const container = document.getElementById('canvas-container');
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.setClearColor(0xffffff, 1);
    container.innerHTML = ''; // clear
    container.appendChild(renderer.domElement);

    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.01, 1000);
    camera.position.set(1.0, 1.0, 1.0);
    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.target.set(0.25, 0.0, 0.0);
    controls.update();

    // lights
    const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.8);
    dir.position.set(5, 5, 2);
    scene.add(dir);

    window.addEventListener('resize', onWindowResize);
    animate();
  }

  function onWindowResize() {
    const container = document.getElementById('canvas-container');
    if (!renderer) return;
    renderer.setSize(container.clientWidth, container.clientHeight);
    camera.aspect = container.clientWidth / container.clientHeight;
    camera.updateProjectionMatrix();
  }

  function animate() {
    requestAnimationFrame(animate);
    if (controls) controls.update();
    if (renderer) renderer.render(scene, camera);
  }

  function buildThreeMesh(vertices, faces, color=0x1f77b4) {
    // vertices: flat array [x0,y0,z0, x1,y1,z1, ...]
    // faces: flat array of indices [a0,b0,c0, a1,b1,c1, ...]
    const geom = new THREE.BufferGeometry();
    const verts = new Float32Array(vertices);
    geom.setAttribute('position', new THREE.BufferAttribute(verts, 3));
    geom.setIndex(faces);
    geom.computeVertexNormals();
    const mat = new THREE.MeshStandardMaterial({ color: color, metalness:0.2, roughness:0.6, side: THREE.DoubleSide });
    const mesh = new THREE.Mesh(geom, mat);
    return mesh;
  }

  // Download STL using three.js exporter
  function downloadSTL() {
    if (!wingMesh) { alert('Generate the wing first'); return; }
    const exporter = new THREE.STLExporter();
    const result = exporter.parse(wingMesh, { binary: true });
    const blob = new Blob([result], { type: 'application/octet-stream' });
    const filename = 'wing_model.stl';
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = filename;
    link.click();
    URL.revokeObjectURL(link.href);
  }

  // Initialize three.js canvas
  initThree();

  // Pyodide setup and Python mesh builder
  let pyodideReady = null;
  async function loadPyodideAndPackages() {
    document.getElementById('status').innerText = 'Loading Pyodide... (this may take a few seconds)';
    const pyodide = await loadPyodide();
    document.getElementById('status').innerText = 'Pyodide ready. Loading numpy...';
    await pyodide.loadPackage('numpy');
    document.getElementById('status').innerText = 'numpy loaded. Ready.';
    return pyodide;
  }

  pyodideReady = loadPyodideAndPackages();

  // Python code to generate wing (NACA 4-digit analytic)
  const pythonMeshBuilder = `
import numpy as np
def naca4_coords(code: str, n_points=100):
    code = code.strip()
    if len(code) != 4 or not code.isdigit():
        raise ValueError("NACA code must be 4 digits")
    m = int(code[0]) / 100.0
    p = int(code[1]) / 10.0
    t = int(code[2:]) / 100.0
    beta = np.linspace(0.0, np.pi, n_points)
    x = 0.5 * (1 - np.cos(beta))
    yt = 5 * t * (0.2969*np.sqrt(x) - 0.1260*x - 0.3516*x**2 + 0.2843*x**3 - 0.1015*x**4)
    yc = np.zeros_like(x)
    dyc_dx = np.zeros_like(x)
    if m>0 and p>0:
        for i, xi in enumerate(x):
            if xi < p:
                yc[i] = (m / (p**2)) * (2*p*xi - xi**2)
                dyc_dx[i] = (2*m / (p**2)) * (p - xi)
            else:
                yc[i] = (m / ((1-p)**2)) * ((1 - 2*p) + 2*p*xi - xi**2)
                dyc_dx[i] = (2*m / ((1-p)**2)) * (p - xi)
    theta = np.arctan(dyc_dx)
    xu = x - yt * np.sin(theta)
    yu = yc + yt * np.cos(theta)
    xl = x + yt * np.sin(theta)
    yl = yc - yt * np.cos(theta)
    return xu, yu, xl, yl

def build_wing_mesh(naca_code='2412', span=2.0, chord_root=0.5, chord_tip=0.3, n_span=21, n_chord=64, twist_root_deg=0.0, twist_tip_deg=0.0, sweep_le_deg=0.0, mirror=True):
    # build airfoil coordinates normalized to chord=1
    xu, yu, xl, yl = naca4_coords(naca_code, n_chord)
    x_chord = np.concatenate([xu, xl[::-1]])
    y_chord = np.concatenate([yu, yl[::-1]])
    # span stations
    if mirror:
        half_span = span / 2.0
        span_stations = np.linspace(0.0, half_span, n_span)
    else:
        span_stations = np.linspace(0.0, span, n_span)
    chords = np.linspace(chord_root, chord_tip, len(span_stations))
    twists = np.deg2rad(np.linspace(twist_root_deg, twist_tip_deg, len(span_stations)))
    sweep_le = np.deg2rad(sweep_le_deg)
    le_offsets = np.tan(sweep_le) * span_stations
    verts = []
    for ys, c, twist, le_off in zip(span_stations, chords, twists, le_offsets):
        xs_local = x_chord * c + le_off
        zs_local = y_chord * c
        ys_local = np.full_like(xs_local, ys)
        # rotate around leading edge (pitch) with twist
        x_rel = xs_local - le_off
        z_rel = zs_local
        cos_t = np.cos(twist)
        sin_t = np.sin(twist)
        x_rot = le_off + cos_t * x_rel - sin_t * z_rel
        z_rot = sin_t * x_rel + cos_t * z_rel
        for xg, yg, zg in zip(x_rot, ys_local, z_rot):
            verts.append((float(xg), float(yg), float(zg)))
    verts = np.array(verts, dtype=float)
    n_c = len(x_chord)
    faces = []
    n_span_st = len(span_stations)
    for j in range(n_span_st - 1):
        for i in range(n_c - 1):
            v00 = j * n_c + i
            v01 = j * n_c + i + 1
            v10 = (j + 1) * n_c + i
            v11 = (j + 1) * n_c + i + 1
            faces.append((v00, v10, v11))
            faces.append((v00, v11, v01))
    if mirror:
        verts_mirror = verts.copy()
        verts_mirror[:,1] *= -1.0
        verts_full = np.vstack([verts, verts_mirror[n_c:]])
        offset = verts.shape[0]
        faces_full = list(faces)
        for (a,b,c) in faces:
            faces_full.append((a + offset - n_c, b + offset - n_c, c + offset - n_c))
        verts = verts_full
        faces = faces_full
    # flatten for JS transfer
    verts_flat = verts.reshape(-1).tolist()
    faces_flat = [int(x) for tri in faces for x in tri]
    return verts_flat, faces_flat
`;

  // Helper to call Python builder with current UI inputs
  async function generateMeshFromPython() {
    const pyodide = await pyodideReady;
    document.getElementById('status').innerText = 'Generating mesh in Python...';
    // ensure the Python code is loaded
    await pyodide.runPythonAsync(pythonMeshBuilder);

    // read inputs
    const params = {
      naca: document.getElementById('naca').value || '2412',
      span: parseFloat(document.getElementById('span').value) || 2.0,
      chord_root: parseFloat(document.getElementById('chord_root').value) || 0.5,
      chord_tip: parseFloat(document.getElementById('chord_tip').value) || 0.3,
      n_span: Math.max(2, parseInt(document.getElementById('n_span').value) || 21),
      n_chord: Math.max(4, parseInt(document.getElementById('n_chord').value) || 64),
      twist_root_deg: parseFloat(document.getElementById('twist_root').value) || 0.0,
      twist_tip_deg: parseFloat(document.getElementById('twist_tip').value) || 0.0,
      sweep_le_deg: parseFloat(document.getElementById('sweep').value) || 0.0,
      mirror: document.getElementById('mirror').checked
    };

    // Build Python call string with safe interpolation
    const call = `
verts_flat, faces_flat = build_wing_mesh(
    naca_code=${JSON.stringify(params.naca)},
    span=${params.span},
    chord_root=${params.chord_root},
    chord_tip=${params.chord_tip},
    n_span=${params.n_span},
    n_chord=${params.n_chord},
    twist_root_deg=${params.twist_root_deg},
    twist_tip_deg=${params.twist_tip_deg},
    sweep_le_deg=${params.sweep_le_deg},
    mirror=${params.mirror}
)
(verts_flat, faces_flat)
`;
    try {
      // execute and retrieve the tuple result
      const res = await pyodide.runPythonAsync(call);
      // Pyodide returns PyProxy for lists; convert to JS arrays using toJs()
      // For this pattern, runPythonAsync returns a PyProxy that supports toJs
      const verts_flat = res[0].toJs ? res[0].toJs() : res[0];
      const faces_flat = res[1].toJs ? res[1].toJs() : res[1];
      document.getElementById('status').innerText = `Mesh ready: ${verts_flat.length/3} vertices, ${faces_flat.length/3} triangles`;
      return { verts_flat, faces_flat };
    } catch (err) {
      console.error(err);
      document.getElementById('status').innerText = 'Python error: ' + err;
      throw err;
    }
  }

  // Hook UI
  document.getElementById('gen').addEventListener('click', async () => {
    try {
      const { verts_flat, faces_flat } = await generateMeshFromPython();
      // remove previous mesh
      if (wingMesh) { scene.remove(wingMesh); wingMesh.geometry.dispose(); wingMesh.material.dispose(); wingMesh = null; }
      const mesh = buildThreeMesh(verts_flat, faces_flat, 0x1f77b4);
      wingMesh = mesh;
      scene.add(mesh);
      // auto-fit camera / center
      fitCameraToObject(camera, controls, mesh, 1.4);
    } catch (e) {
      console.error(e);
    }
  });

  document.getElementById('download_stl').addEventListener('click', () => {
    downloadSTL();
  });

  // utility to frame object
  function fitCameraToObject( camera, controls, object, offset = 1.25 ) {
    const boundingBox = new THREE.Box3();
    boundingBox.setFromObject( object );
    const center = boundingBox.getCenter(new THREE.Vector3());
    const size = boundingBox.getSize(new THREE.Vector3());
    const maxSize = Math.max(size.x, size.y, size.z);
    const fitHeightDistance = maxSize / (2 * Math.atan(Math.PI * camera.fov / 360));
    const fitWidthDistance = fitHeightDistance / camera.aspect;
    const distance = offset * Math.max(fitHeightDistance, fitWidthDistance);
    // move camera to center + distance
    const dir = controls.target.clone()
      .sub(camera.position)
      .normalize()
      .multiplyScalar(-1);
    camera.position.copy(center);
    camera.position.add(new THREE.Vector3(distance, distance, distance));
    camera.lookAt(center);
    controls.target.copy(center);
    controls.update();
  }

  // initial generation once pyodide is ready
  (async () => {
    try {
      await pyodideReady;
      document.getElementById('status').innerText = 'Pyodide ready. Click Generate to build the wing.';
      // optional: generate automatically once ready
      // document.getElementById('gen').click();
    } catch (err) {
      document.getElementById('status').innerText = 'Failed to load Pyodide: ' + err;
    }
  })();

</script>
</body>
</html>
